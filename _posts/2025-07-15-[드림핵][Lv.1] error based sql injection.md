---
layout: post
published : false  # 글 비공개 설정
title: "[드림핵][Lv.1] error based sql injection 문제 풀이"
date:   2025-07-15 18:00:00 +0900
categories: [Security]
tags: [wargame, web, error-sqli]
---

## 1. 개요 (Overview)

- **플랫폼 (Platform)**: 드림핵
- **문제 이름 (Challenge)**: error based sql injection
- **분야 (Category)**: 웹해킹
- **문제 링크 (URL)**: [드림핵 워게임](https://dreamhack.io/wargame/challenges/412)



## 2. 문제 분석 (Problem Analysis)

```python
# app.py
@app.route('/', methods=['POST', 'GET'])

def index():

uid = request.args.get('uid')

if uid:

try:

cur = mysql.connection.cursor()

cur.execute(f"SELECT * FROM user WHERE uid='{uid}';")

return template.format(uid=uid)

except Exception as e:

return str(e)

else:

return template
```

---

### 1. 문제 해설
- 이 문제의 핵심은 Error based SQLi 대표적인 문제이다
- 먼저 Error based SQLi 의 대표적인 함수를 알아보면 2가지가 있다.

#### 1) EXTRACTVALUE() 함수를 이용한 공격
- extractvalue() 함수는 XML 데이터에서 특정 경로(XPath)에 해당하는 값을 추출하는 함수 이다.
- 이 때 두 분째 인자인 XPath 경로에 잘못된 문법을 삽입하면 에러가 발생하며, 이 에러 메시지에 우리가 원하는 정보가 포함되도록 유도할 수 있다.

- **기본 문법:** EXTRACTVALUE(XML_document, XPath_string)

<br>

##### 1-1) 대표 스크립트 예시 (MySQL/MariaDB 기준)
**대표 스크립트 (데이터베이스 버전 확인)**

```sql
' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT @@version))) --
```

**스크립트 상세 설명**
- `'`: 앞선 SQL 쿼리의 작은따옴표를 닫아 구문을 완료.
- `AND`: 논리 연산자를 사용하여 추가적인 조건을 연결한다.
- `EXTRACTVALUE(1, ...)`: `EXTRACTVALUE` 함수를 호출한다.
    - **첫 번째 인자 (`1`):** XML 문서 자리에 임의의 값(숫자 1)을 넣는다.(이 값 자체는 중요하지 않다.)
    - **두 번째 인자 (`CONCAT(0x3a, (SELECT @@version))`)**: XPath 경로 부분
        - `CONCAT()`: 여러 문자열을 하나로 합치는 함수이다.
        - `0x3a`: 콜론(`:`)의 16진수 표현한다는 표시, XPath 문법은 콜론으로 시작할 수 없기 때문에, 의도적으로 에러를 발생시키기 위해 사용한다.
        - `(SELECT @@version)`: 우리가 **알고 싶어 하는 정보**를 가져오는 쿼리이다. 여기서는 데이터베이스의 버전(`@@version`)을 조회한다.
- `--` : 뒤에 올 수 있는 나머지 SQL 쿼리 구문을 무시하여 문법 오류를 방지한다.

<br>
---


#### 2) UPDATEXML() 함수를 이용한 공격
- `UPDATEXML()` 함수는 **XML 데이터의 특정 부분**을 **다른 XML 조각으로 교체하는 함수**이다.
- `EXTRACTVALUE()`와 마찬가지로, **XPath 경로에 잘못된 문법을 넣어 에러를 유발하는 방식**으로 정보를 탈취한다.

- **기본 문법:** `UPDATEXML(XML_document, XPath_string, new_value_XML_frag)`

<br>

##### 2-1) 대표 스크립트 (현재 사용자 정보 확인)

```sql
' AND UPDATEXML(1, CONCAT(0x3a, (SELECT USER())), 1) --
```

<br>

##### 2-2) 스크립트 상세 설명
- `' AND UPDATEXML(1, ..., 1) --`: 전체적인 구조는 `EXTRACTVALUE`와 매우 유사하다.
    - **첫 번째 인자 (`1`):** 대상 XML 문서 자리에 임의의 값을 넣는다.
    - **두 번째 인자 (`CONCAT(0x3a, (SELECT USER()))`)**: 에러를 유발할 XPath 경로이다.
        - `0x3a`: 에러를 유발하기 위한 콜론(`:`)
        - `(SELECT USER())`: **알고 싶어 하는 정보**, 즉 현재 데이터베이스 사용자
          (예: `root@localhost`)를 가져온다.
    - **세 번째 인자 (`1`):** 변경할 XML 조각 자리에 임의의 값을 넣는다.

<br>

##### 2-3) 작동 원리
- `EXTRACTVALUE`와 동일
- `SELECT USER()`가 실행되어 사용자 정보를 반환하고, `CONCAT` 함수가 이를 콜론과 합쳐진다.
- 이 잘못된 XPath 경로로 인해 `UPDATEXML` 함수가 에러를 발생시키고, 에러 메시지에 사용자 정보가 노출 된다.

--- 

#### 3) 실제 문제의 스크립트 작성
~~~sql
' OR UPDATEXML(1, CONCAT(0x3a, (SELECT upw FROM user WHERE uid = 'admin')), 1) --
~~~
- 위와 같이 입력 시 에러가 발생하는 모습을 확인 했다. 
- 아마도 **문자가 필터링되고 있을 가능성**이 있는것 같다.

<br>

##### 3-1) 우회 시도 : Hex 인코딩 사용
- 위 처럼 따옴표 사용이 막혀을 때 가장 대표적인 우회 방법은 문자열을 16진수 값으로 인코딩하여 사용하는 것이다.
- 0x.... 형태로 시작하는 값을 16진수 문자열로 인식하기 때문에 따옴표 없이도 문자열을 표현 할 수 있다.
- 문자열 `'admin'`을 16진수로 변환하면 `0x61646d696e`가 됩니다.
	- `a` -> `61`
	- `d` -> `64`
	- `m` -> `6d`
	- `i` -> `69`
	- `n` -> `6e`

<br>

- **수정된 최종 Payload**
~~~sql
' OR UPDATEXML(1, CONCAT(0x3a, (SELECT upw FROM user WHERE uid = 0x61646d696e)), 1) #		
~~~

- UPDATEXML() 함수를 사용한 Error-based SQLi는 **"에러 메시지에 출력될 수 있는 문자열의 길이가 32자로 제한"** 되어 있어 긴 데이터를 한 번에 볼 수 없다.
- 이럴 때는 **"AUBSTRING()"** 함수를 사용한다.
	- 문자열의 특정 부분만 잘라내는 역할
	- - **기본 문법:** `SUBSTRING(자를 문자열, 시작 위치, 가져올 길이)`
	- **예시:** `SELECT SUBSTRING('ABCDEFG', 1, 3);` → 'ABC'를 반환
	- **예시:** `SELECT SUBSTRING('ABCDEFG', 4, 2);` → 'DE'를 반환

<br>

##### 3-2) 첫번째 부분 추출(1~30자)
~~~mysql
' OR UPDATEXML(1, CONCAT(0x3a, (SELECT SUBSTRING(upw, 1, 30) FROM user WHERE uid = 0x61646d696e)), 1) #
~~~
- `SUBSTRING(upw, 1, 30)`: `upw` 컬럼 값의 **1번째** 글자부터 **30개**

<br>

##### 3-3) 두번째 부분 추출(31~61자)
~~~sql
' OR UPDATEXML(1, CONCAT(0x3a, (SELECT SUBSTRING(upw, 31, 30) FROM user WHERE uid = 0x61646d696e)), 1) #
~~~
- `SUBSTRING(upw, 31, 30)`: `upw` 컬럼 값의 **31번째** 글자부터 **30개** 잘라 낸다.
- 이제 추출한 DH{} 값을 합치면 최종 Flag 값을 확인 할 수 있다.


---